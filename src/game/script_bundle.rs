use std::fs;
use std::path::{Path, PathBuf};

use crate::config::WorldConfig;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum ScriptClass {
    Script,
    ModuleScript,
}

impl ScriptClass {
    fn as_lua_class_name(self) -> &'static str {
        match self {
            ScriptClass::Script => "Script",
            ScriptClass::ModuleScript => "ModuleScript",
        }
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum ServiceRoot {
    ServerScriptService,
    Workspace,
}

impl ServiceRoot {
    fn as_str(self) -> &'static str {
        match self {
            ServiceRoot::ServerScriptService => "ServerScriptService",
            ServiceRoot::Workspace => "Workspace",
        }
    }
}

#[derive(Debug, Clone)]
struct ScriptFile {
    source: String,
    name: String,
    folders: Vec<String>,
    class: ScriptClass,
    service: ServiceRoot,
}

pub fn load_world_and_entry_script(game_dir: &Path) -> Result<(WorldConfig, String), String> {
    let config = WorldConfig::from_game_dir(game_dir)
        .map_err(|e| format!("Error loading world.toml: {}", e))?;
    let entry_script = build_entry_script(game_dir, &config)?;
    Ok((config, entry_script))
}

pub fn build_entry_script(game_dir: &Path, config: &WorldConfig) -> Result<String, String> {
    let main_path = game_dir.join(&config.scripts.main);
    let main_script = fs::read_to_string(&main_path)
        .map_err(|e| format!("Error reading {}: {}", main_path.display(), e))?;

    let script_files = load_script_tree_files(game_dir, config)?;
    if script_files.is_empty() {
        return Ok(main_script);
    }

    let mut bootstrap = String::new();
    bootstrap.push_str("-- Auto-generated by clawblox script bundle loader.\n");
    bootstrap.push_str("-- 1) Materialize script tree from disk\n");
    bootstrap.push_str("-- 2) Execute world entrypoint\n\n");

    for script in &script_files {
        bootstrap.push_str("do\n");
        bootstrap.push_str("  local parent = game:GetService(");
        bootstrap.push_str(&lua_quoted(script.service.as_str()));
        bootstrap.push_str(")\n");

        for folder in &script.folders {
            bootstrap.push_str("  do\n");
            bootstrap.push_str("    local nextFolder = parent:FindFirstChild(");
            bootstrap.push_str(&lua_quoted(folder));
            bootstrap.push_str(")\n");
            bootstrap.push_str("    if not nextFolder then\n");
            bootstrap.push_str("      nextFolder = Instance.new(\"Folder\")\n");
            bootstrap.push_str("      nextFolder.Name = ");
            bootstrap.push_str(&lua_quoted(folder));
            bootstrap.push_str("\n");
            bootstrap.push_str("      nextFolder.Parent = parent\n");
            bootstrap.push_str("    end\n");
            bootstrap.push_str("    parent = nextFolder\n");
            bootstrap.push_str("  end\n");
        }

        bootstrap.push_str("  local scriptInstance = Instance.new(");
        bootstrap.push_str(&lua_quoted(script.class.as_lua_class_name()));
        bootstrap.push_str(")\n");
        bootstrap.push_str("  scriptInstance.Name = ");
        bootstrap.push_str(&lua_quoted(&script.name));
        bootstrap.push_str("\n");
        bootstrap.push_str("  scriptInstance.Source = ");
        bootstrap.push_str(&lua_long_string(&script.source));
        bootstrap.push_str("\n");
        bootstrap.push_str("  scriptInstance.Parent = parent\n");
        bootstrap.push_str("end\n\n");
    }

    bootstrap.push_str("-- Entrypoint: ");
    bootstrap.push_str(&config.scripts.main);
    bootstrap.push_str("\n");
    bootstrap.push_str(&main_script);
    bootstrap.push('\n');
    Ok(bootstrap)
}

fn load_script_tree_files(game_dir: &Path, config: &WorldConfig) -> Result<Vec<ScriptFile>, String> {
    let Some(root_dir) = resolve_tree_root(game_dir, config)? else {
        return Ok(Vec::new());
    };

    let mut lua_files = Vec::new();
    collect_lua_files(&root_dir, &root_dir, &mut lua_files)?;
    lua_files.sort_by(|a, b| a.0.cmp(&b.0));

    let mut parsed = Vec::with_capacity(lua_files.len());
    for (relative_path, absolute_path) in lua_files {
        parsed.push(parse_script_file(&relative_path, &absolute_path)?);
    }
    Ok(parsed)
}

fn resolve_tree_root(game_dir: &Path, config: &WorldConfig) -> Result<Option<PathBuf>, String> {
    if let Some(tree_dir) = &config.scripts.tree {
        let root = game_dir.join(tree_dir);
        if !root.is_dir() {
            return Err(format!(
                "scripts.tree points to missing directory: {}",
                root.display()
            ));
        }
        return Ok(Some(root));
    }

    let default_root = game_dir.join("scripts");
    if default_root.is_dir() {
        Ok(Some(default_root))
    } else {
        Ok(None)
    }
}

fn collect_lua_files(
    root_dir: &Path,
    current_dir: &Path,
    out: &mut Vec<(String, PathBuf)>,
) -> Result<(), String> {
    let entries = fs::read_dir(current_dir)
        .map_err(|e| format!("Error reading {}: {}", current_dir.display(), e))?;

    for entry in entries {
        let entry = entry.map_err(|e| format!("Error scanning {}: {}", current_dir.display(), e))?;
        let path = entry.path();
        if path.is_dir() {
            collect_lua_files(root_dir, &path, out)?;
            continue;
        }

        if path.extension().and_then(|s| s.to_str()) != Some("lua") {
            continue;
        }

        let rel = path
            .strip_prefix(root_dir)
            .map_err(|e| format!("Failed to relativize {}: {}", path.display(), e))?;
        let rel = rel.to_string_lossy().replace('\\', "/");
        out.push((rel, path));
    }

    Ok(())
}

fn parse_script_file(relative_path: &str, absolute_path: &Path) -> Result<ScriptFile, String> {
    let parts: Vec<&str> = relative_path.split('/').collect();
    if parts.len() < 2 {
        return Err(format!(
            "Invalid script path '{}': expected <Service>/<file.lua>",
            relative_path
        ));
    }

    let service = match parts[0] {
        "ServerScriptService" => ServiceRoot::ServerScriptService,
        "Workspace" => ServiceRoot::Workspace,
        other => {
            return Err(format!(
                "Unsupported script service root '{}' in '{}'; expected ServerScriptService or Workspace",
                other, relative_path
            ))
        }
    };

    let filename = parts[parts.len() - 1];
    let (class, name) = classify_script_file_name(filename).ok_or_else(|| {
        format!(
            "Unsupported script file '{}' in '{}'; use .lua/.server.lua/.script.lua/.module.lua",
            filename, relative_path
        )
    })?;

    let folders = parts[1..parts.len() - 1]
        .iter()
        .map(|s| s.to_string())
        .collect();

    let source = fs::read_to_string(absolute_path)
        .map_err(|e| format!("Error reading {}: {}", absolute_path.display(), e))?;

    Ok(ScriptFile {
        source,
        name,
        folders,
        class,
        service,
    })
}

fn classify_script_file_name(filename: &str) -> Option<(ScriptClass, String)> {
    if let Some(name) = filename.strip_suffix(".module.lua") {
        return Some((ScriptClass::ModuleScript, name.to_string()));
    }
    if let Some(name) = filename.strip_suffix(".server.lua") {
        return Some((ScriptClass::Script, name.to_string()));
    }
    if let Some(name) = filename.strip_suffix(".script.lua") {
        return Some((ScriptClass::Script, name.to_string()));
    }
    if let Some(name) = filename.strip_suffix(".lua") {
        return Some((ScriptClass::Script, name.to_string()));
    }
    None
}

fn lua_quoted(text: &str) -> String {
    let mut out = String::with_capacity(text.len() + 2);
    out.push('"');
    for ch in text.chars() {
        match ch {
            '\\' => out.push_str("\\\\"),
            '"' => out.push_str("\\\""),
            '\n' => out.push_str("\\n"),
            '\r' => out.push_str("\\r"),
            '\t' => out.push_str("\\t"),
            c => out.push(c),
        }
    }
    out.push('"');
    out
}

fn lua_long_string(text: &str) -> String {
    for level in 0..8 {
        let eq = "=".repeat(level);
        let close = format!("]{}]", eq);
        if text.contains(&close) {
            continue;
        }
        let open = format!("[{}[", eq);
        return format!("{}{}{}", open, text, close);
    }
    lua_quoted(text)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_classify_script_file_name() {
        assert_eq!(
            classify_script_file_name("Boot.server.lua"),
            Some((ScriptClass::Script, "Boot".to_string()))
        );
        assert_eq!(
            classify_script_file_name("Shared.module.lua"),
            Some((ScriptClass::ModuleScript, "Shared".to_string()))
        );
        assert_eq!(
            classify_script_file_name("Legacy.lua"),
            Some((ScriptClass::Script, "Legacy".to_string()))
        );
        assert_eq!(classify_script_file_name("README.md"), None);
    }

    #[test]
    fn test_lua_long_string_falls_back_when_needed() {
        let s = "hello ]]]===]";
        let rendered = lua_long_string(s);
        assert!(!rendered.is_empty());
    }
}
